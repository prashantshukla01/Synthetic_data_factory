{"messages": [{"role": "user", "content": "Advanced Python Decorators"}, {"role": "assistant", "content": [{"type": "text", "text": "Advanced Python decorators go far beyond simple logging or timing. They involve understanding the closure property of functions, the descriptor protocol, and the nuances of Python\u2019s data model.\n\nHere is a deep dive into advanced decorator patterns.\n\n---\n\n### 1. The Essential: `functools.wraps`\nWhen you wrap a function, you lose its metadata (like `__name__`, `__doc__`, and type hints). Advanced decorators must always use `@functools.wraps`.\n\n```python\nimport functools\n\ndef my_decorator(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        \"\"\"Wrapper docstring\"\"\"\n        return func(*args, **kwargs)\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    \"\"\"Original docstring\"\"\"\n    print(\"Hello!\")\n\nprint(say_hello.__name__)  # 'say_hello' (instead of 'wrapper')\nprint(say_hello.__doc__)   # 'Original docstring'\n```\n\n---\n\n### 2. Decorators with Arguments (The Triple Nest)\nTo pass arguments to a decorator (e.g., `@repeat(times=3)`), you need three levels of functions:\n1. The **Outer Factory**: Accepts the configuration arguments.\n2. The **Decorator**: Accepts the function to be decorated.\n3. The **Wrapper**: Handles the actual execution.\n\n```python\ndef repeat(times):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n\n@repeat(times=3)\ndef greet(name):\n    print(f\"Hello, {name}\")\n\ngreet(\"Alice\") # Prints 3 times\n```\n\n---\n\n### 3. Class-Based Decorators\nClasses can act as decorators by implementing the `__call__` method. This is useful for maintaining state across calls.\n\n```python\nclass CallCounter:\n    def __init__(self, func):\n        functools.update_wrapper(self, func)\n        self.func = func\n        self.count = 0\n\n    def __call__(self, *args, **kwargs):\n        self.count += 1\n        print(f\"Call {self.count} of {self.func.__name__}\")\n        return self.func(*args, **kwargs)\n\n@CallCounter\ndef do_something():\n    pass\n\ndo_something()\ndo_something() # count = 2\n```\n*Note: Using class decorators on **instance methods** requires extra care (the descriptor protocol) because they don't automatically bind `self`.*\n\n---\n\n### 4. Decorating Entire Classes\nYou can apply a decorator to a class definition. This allows you to modify the class before it is instantiated, often used as an alternative to Metaclasses.\n\n```python\ndef add_timestamp(cls):\n    cls.timestamp = \"2023-10-27\"\n    return cls\n\n@add_timestamp\nclass MyClass:\n    pass\n\nprint(MyClass.timestamp) # 2023-10-27\n```\n\n---\n\n### 5. Stateful Decorators (Function Attributes)\nFunctions are objects in Python. You can attach state directly to the wrapper function to avoid the overhead of a class.\n\n```python\ndef singleton(cls):\n    \"\"\"Make a class a Singleton.\"\"\"\n    instances = {}\n    @functools.wraps(cls)\n    def wrapper(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n    return wrapper\n\n@singleton\nclass DatabaseConnection:\n    pass\n```\n\n---\n\n### 6. Handling Async Decorators\nWith the rise of `asyncio`, you often need to decorate `async def` functions. The wrapper itself must be `async`.\n\n```python\nimport asyncio\n\ndef async_timer(func):\n    @functools.wraps(func)\n    async def wrapper(*args, **kwargs):\n        start = asyncio.get_event_loop().time()\n        result = await func(*args, **kwargs)\n        end = asyncio.get_event_loop().time()\n        print(f\"Executed in {end - start:.4f}s\")\n        return result\n    return wrapper\n\n@async_timer\nasync def download_data():\n    await asyncio.sleep(1)\n\n# asyncio.run(download_data())\n```\n\n---\n\n### 7. Advanced: The \"Optional Argument\" Decorator\nSometimes you want to support both `@decorator` and `@decorator(arg=val)`. This requires checking if the first argument is a callable.\n\n```python\ndef smart_decorator(_func=None, *, prefix=\"DEBUG\"):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            print(f\"[{prefix}] Calling {func.__name__}\")\n            return func(*args, **kwargs)\n        return wrapper\n\n    if _func is None:\n        return decorator\n    return decorator(_func)\n\n@smart_decorator\ndef foo(): pass\n\n@smart_decorator(prefix=\"INFO\")\ndef bar(): pass\n```\n\n---\n\n### 8. Real-World Use Cases\n1. **Validation/Type Checking**: Checking arguments before execution.\n2. **Caching (Memoization)**: Storing results of expensive calls (see `functools.lru_cache`).\n3. **Authorization**: Checking user permissions in web frameworks (Django/Flask).\n4. **Rate Limiting**: Restricting how often a function can be called.\n5. **Context Injection**: Automatically passing a database session or logger to the function.\n\n### Best Practices\n*   **Keep it simple:** If a decorator makes code harder to debug, consider if a Context Manager or simple function call is better.\n*   **Debugging:** Use `func.__wrapped__` to access the original, undecorated function (provided by `functools.wraps`).\n*   **Side Effects:** Avoid heavy logic inside the decorator factory; keep it in the wrapper.", "extras": {"signature": "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"}}]}]}
{"messages": [{"role": "user", "content": "Advanced Python Decorators"}, {"role": "assistant", "content": [{"type": "text", "text": "Python decorators are a powerful tool for modifying or enhancing the behavior of functions or classes. While basic decorators are simple wrappers, **Advanced Decorators** involve complex concepts like state management, arguments, class-based structures, and asynchronous support.\n\n---\n\n### 1. The Foundation: `functools.wraps`\nWhen you wrap a function, you often lose its metadata (like its name, docstring, and type hints). Advanced decorators always use `functools.wraps` to preserve this information.\n\n```python\nfrom functools import wraps\n\ndef debug(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print(f\"Calling {func.__name__}\")\n        return func(*args, **kwargs)\n    return wrapper\n```\n\n---\n\n### 2. Decorators with Arguments (Decorator Factories)\nTo pass arguments to a decorator (e.g., `@repeat(times=3)`), you need an extra layer of nesting. The outer function acts as a **factory** that returns the actual decorator.\n\n```python\ndef repeat(times):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n\n@repeat(times=3)\ndef greet(name):\n    print(f\"Hello, {name}\")\n\n# greet(\"Alice\") will print 3 times.\n```\n\n---\n\n### 3. Class-Based Decorators\nSometimes, using a class is cleaner than nested functions, especially if you need to maintain complex state.\n\n#### A. Using `__call__`\nBy implementing the `__call__` method, an instance of a class can behave like a function.\n\n```python\nclass CountCalls:\n    def __init__(self, func):\n        wraps(func)(self)\n        self.func = func\n        self.num_calls = 0\n\n    def __call__(self, *args, **kwargs):\n        self.num_calls += 1\n        print(f\"Call {self.num_calls} of {self.func.__name__}\")\n        return self.func(*args, **kwargs)\n\n@CountCalls\ndef say_hi():\n    print(\"Hi!\")\n```\n\n---\n\n### 4. Stateful Decorators\nAdvanced decorators can \"remember\" data across different function calls. This is useful for **Caching (Memoization)** or **Rate Limiting**.\n\n```python\ndef memoize(func):\n    cache = {}\n    @wraps(func)\n    def wrapper(*args):\n        if args not in cache:\n            cache[args] = func(*args)\n        return cache[args]\n    return wrapper\n\n@memoize\ndef heavy_computation(x):\n    # Imagine a slow process here\n    return x * x\n```\n\n---\n\n### 5. Decorating Entire Classes\nYou can apply a decorator to a class definition. This allows you to modify how the class is instantiated or add methods to it dynamically.\n\n**Example: A Singleton Pattern**\n```python\ndef singleton(cls):\n    instances = {}\n    @wraps(cls)\n    def get_instance(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n    return get_instance\n\n@singleton\nclass DatabaseConnection:\n    def __init__(self):\n        print(\"Connecting to DB...\")\n```\n\n---\n\n### 6. Asynchronous Decorators\nWith the rise of `asyncio`, you often need to decorate `async` functions. A standard decorator will break an `async` function because it doesn't return a coroutine.\n\n```python\nimport asyncio\nimport time\n\ndef async_timer(func):\n    @wraps(func)\n    async def wrapper(*args, **kwargs):\n        start = time.perf_counter()\n        yield_val = await func(*args, **kwargs)\n        end = time.perf_counter()\n        print(f\"{func.__name__} took {end - start:.4f}s\")\n        return yield_val\n    return wrapper\n\n@async_timer\nasync def download_data():\n    await asyncio.sleep(1)\n    return \"Data\"\n```\n\n---\n\n### 7. Optional Arguments Decorator\nA common \"pro\" pattern is creating a decorator that can be used both with and without parentheses:\n`@decorator` OR `@decorator(arg=val)`\n\n```python\ndef smart_decorator(_func=None, *, kwarg1=None):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            print(f\"Kwarg is: {kwarg1}\")\n            return func(*args, **kwargs)\n        return wrapper\n\n    if _func is None:\n        return decorator\n    else:\n        return decorator(_func)\n\n# Both work:\n@smart_decorator\ndef foo(): pass\n\n@smart_decorator(kwarg1=\"test\")\ndef bar(): pass\n```\n\n---\n\n### Summary Table: When to use what?\n\n| Pattern | Best Use Case |\n| :--- | :--- |\n| **Simple Wrapper** | Logging, timing, or access control. |\n| **Decorator Factory** | When the decorator behavior needs configuration (e.g., retry N times). |\n| **Class-based** | When the decorator needs to maintain complex state or provide extra methods. |\n| **Class Decorator** | Implementing Singletons or automatically registering classes into a registry. |\n| **Async Decorator** | When working with `asyncio`, Web APIs, or database drivers. |\n\n### Best Practices\n1. **Always use `functools.wraps`**: It prevents debugging nightmares.\n2. **Keep it readable**: If a decorator is more than 3 levels deep, consider using a Class-based approach.\n3. **Side Effects**: Avoid decorators that change the return type of the function unexpectedly, as this breaks type hinting and IDE support.", "extras": {"signature": "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"}}]}]}
{"messages": [{"role": "user", "content": "C++ Memory Management"}, {"role": "assistant", "content": [{"type": "text", "text": "This guide provides a comprehensive overview of **Modern C++ Memory Management**, transitioning from manual resource handling to the \"Resource Acquisition Is Initialization\" (RAII) paradigm. It focuses on safety, efficiency, and idiomatic C++11/14/17/20 practices.\n\n---\n\n### 1. The Core Philosophy: RAII\nRAII is the cornerstone of C++ memory management. It ensures that resources (memory, file handles, sockets) are tied to object lifetime.\n*   **Acquisition:** Resources are acquired in the constructor.\n*   **Release:** Resources are released in the destructor.\n*   **Benefit:** Automatic cleanup occurs when the object goes out of scope, even if an exception is thrown.\n\n```cpp\nclass ResourceManager {\n    int* data;\npublic:\n    ResourceManager(size_t size) : data(new int[size]) {} // Acquire\n    ~ResourceManager() { delete[] data; }                // Release\n};\n```\n\n---\n\n### 2. Smart Pointers (The Modern Standard)\nSince C++11, manual `new` and `delete` are largely discouraged in favor of smart pointers found in the `<memory>` header.\n\n#### A. `std::unique_ptr` (Exclusive Ownership)\nUsed when a resource has a single owner. It cannot be copied, only moved.\n*   **Idiom:** Use `std::make_unique` (C++14) for exception safety and brevity.\n\n```cpp\nauto ptr = std::make_unique<Data>(100);\n// std::unique_ptr<Data> ptr2 = ptr; // Compile Error: Copying forbidden\nstd::unique_ptr<Data> ptr2 = std::move(ptr); // Ownership transferred\n```\n\n#### B. `std::shared_ptr` (Shared Ownership)\nUsed when multiple objects need to share access to a single resource. It uses **reference counting**.\n*   **Idiom:** Use `std::make_shared` to perform a single memory allocation for both the object and the control block.\n\n```cpp\nauto shared1 = std::make_shared<Data>(200);\n{\n    auto shared2 = shared1; // Reference count increments\n} // shared2 out of scope, count decrements\n```\n\n#### C. `std::weak_ptr` (Circular Dependency Breaker)\nA non-owning reference to an object managed by `std::shared_ptr`. It prevents circular references that lead to memory leaks.\n\n```cpp\nstruct Node {\n    std::shared_ptr<Node> next;\n    std::weak_ptr<Node> prev; // Use weak_ptr to avoid cycles\n};\n```\n\n---\n\n### 3. The Rule of Five\nTo manage memory correctly in classes that handle raw resources, you must implement (or explicitly delete) five special member functions:\n\n1.  **Destructor:** Clean up resources.\n2.  **Copy Constructor:** Deep copy resources.\n3.  **Copy Assignment:** Clean up existing and deep copy.\n4.  **Move Constructor:** Transfer ownership (set source to `nullptr`).\n5.  **Move Assignment:** Transfer ownership and clean up old resource.\n\n**The Rule of Zero:** Modern C++ encourages designing classes so that they don't need to manage resources manually (by using smart pointers or STL containers), thus requiring none of the above.\n\n---\n\n### 4. Advanced Patterns: Custom Allocators & Placement New\nFor performance-critical applications (like game engines), standard heap allocation might be too slow.\n\n*   **Placement New:** Constructs an object in a pre-allocated memory buffer.\n*   **Custom Allocators:** Standard Library containers (like `std::vector`) allow passing a custom allocator to control how memory is pooled or aligned.\n\n```cpp\nchar buffer[sizeof(Data)];\nData* d = new (buffer) Data(); // Placement new: no heap allocation\nd->~Data();                   // Manual destructor call required\n```\n\n---\n\n### 5. Common Pitfalls and Best Practices\n*   **Dangling Pointers:** Accessing memory after it has been deleted.\n*   **Memory Leaks:** Forgetting to `delete` or creating circular `shared_ptr` references.\n*   **Double Free:** Deleting the same pointer twice (mitigated by setting pointers to `nullptr` after deletion).\n*   **Modern Rule:** **Never use `new` or `delete`** unless you are implementing a low-level data structure or a custom smart pointer.\n\n---\n\n### Summary Table: C++ Memory Management Reference\n\n| Feature | Ownership | Overhead | Use Case |\n| :--- | :--- | :--- | :--- |\n| **Stack Allocation** | Automatic (Scope) | Zero | Local variables, small objects. Fast. |\n| **`std::unique_ptr`** | Exclusive | Zero/Minimal | Default choice for heap objects. |\n| **`std::shared_ptr`** | Shared | High (Ref Count) | Shared resources, complex graphs. |\n| **`std::weak_ptr`** | Non-owning | Low | Breaking cycles, caching. |\n| **Raw Pointer (`T*`)** | None | Zero | Observing/Passing (if null is possible). |\n| **Reference (`T&`)** | None | Zero | Observing/Passing (if null is impossible). |\n| **`std::vector<T>`** | Contiguous | Minimal | Dynamic arrays (manages own memory). |\n\n---\n\n### Final Pro-Tip: Memory Tools\nEven with smart pointers, bugs happen. Always use tools like **Valgrind** (Linux), **AddressSanitizer (ASan)** (Clang/GCC/MSVC), or **Visual Studio Memory Profiler** to detect leaks and buffer overflows during development.", "extras": {"signature": "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"}}]}]}
{"messages": [{"role": "user", "content": "Fintech API Security"}, {"role": "assistant", "content": [{"type": "text", "text": "This guide outlines the essential architecture and modern standards for **Fintech API Security**. In high-stakes financial environments, security must move beyond basic HTTPS to a **Zero Trust** model, ensuring non-repudiation, data integrity, and strict regulatory compliance (PCI DSS, PSD2, GDPR).\n\n---\n\n### 1. The Core Philosophy: Financial-grade API (FAPI)\nStandard OAuth 2.0 and OpenID Connect (OIDC) are often insufficient for high-value transactions. The **FAPI (Financial-grade API)** profile is the industry benchmark, adding stricter requirements to standard flows.\n*   **Authorization Code Flow with PKCE:** Mandatory to prevent code injection attacks, even for server-side clients.\n*   **Sender-Constrained Tokens:** Use **mTLS (Mutual TLS)** or **DPoP (Demonstrating Proof-of-Possession)** to bind access tokens to the client\u2019s cryptographic key. This ensures that if a token is stolen, it cannot be used by an unauthorized party.\n\n### 2. Authentication & Authorization\n*   **Mutual TLS (mTLS):** Unlike standard TLS, mTLS requires both the client and server to authenticate each other via certificates. This is the gold standard for server-to-server fintech communication.\n*   **Granular Scopes:** Implement the principle of least privilege. Instead of a generic `read_balance` scope, use specific scopes like `accounts:read:limited` to restrict data exposure.\n*   **Strong Customer Authentication (SCA):** Integrate Multi-Factor Authentication (MFA) directly into the API flow, often triggered by \"Step-up Authentication\" for high-risk actions (e.g., transferring >$10,000).\n\n### 3. Data Integrity and Non-Repudiation\nIn fintech, proving that a transaction was not altered and was indeed sent by the user is critical.\n*   **JWS (JSON Web Signatures):** Use JWS to sign the payload. This ensures that if a Man-in-the-Middle (MITM) alters the transaction amount, the signature validation will fail.\n*   **JWE (JSON Web Encryption):** For highly sensitive PII (Personally Identifiable Information), use JWE to provide nested encryption, ensuring only the final intended consumer can decrypt the message, even if the TLS layer is terminated at a Load Balancer.\n*   **Idempotency Keys:** Crucial for financial integrity. Use an `Idempotency-Key` header to prevent accidental double-processing of transactions during network retries.\n\n### 4. Data Protection & Privacy\n*   **Tokenization:** Replace sensitive data (like Primary Account Numbers/PANs) with non-sensitive tokens. The actual data remains in a hardened \"Vault,\" significantly reducing PCI DSS audit scope.\n*   **Field-Level Encryption (FLE):** Encrypt sensitive fields (e.g., SSN, Account Number) before they reach the database, ensuring that even a database breach does not leak plaintext financial data.\n*   **PII Masking:** Ensure logs and monitoring tools automatically redact sensitive information using regex patterns to prevent accidental leakage in observability stacks.\n\n### 5. Defensive Infrastructure\n*   **Rate Limiting & Quotas:** Implement tiered rate limiting (per IP, per API Key, and per User) to mitigate Distributed Denial of Service (DDoS) and brute-force attempts on PINs/passwords.\n*   **API Gateway as a Security Shield:** Use a gateway to handle SSL termination, protocol validation, and schema enforcement (ensuring incoming JSON matches the expected structure to prevent injection).\n*   **Real-time Threat Detection:** Employ AI-driven behavioral analysis to detect anomalies, such as a user suddenly accessing their API from a high-risk geography or performing \"velocity\" attacks (rapid small transactions).\n\n---\n\n### The \"Level 10\" Nuance: Modern Safety Additions\nTo achieve maximum security maturity, consider these advanced practices:\n\n1.  **Object-Level Authorization (BOLA/BFLA):** Beyond checking *if* a user is logged in, verify they own the specific `account_id` requested. Use \"Broken Object Level Authorization\" checks at every controller level.\n2.  **Certificate Pinning:** For mobile fintech apps, use certificate pinning to ensure the app only communicates with your specific server, preventing intercepting proxies (like Charles or Fiddler) from inspecting traffic.\n3.  **Ephemeral Secrets:** Use tools like HashiCorp Vault to generate short-lived dynamic credentials for database access, ensuring that a compromised application server only provides a limited window of vulnerability.\n4.  **DRP (Detailed Response Policy):** Never return stack traces or overly descriptive error messages. Use generic error codes for the client while logging the detailed technical error (with a Correlation ID) internally for debugging.", "extras": {"signature": "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"}}]}]}
